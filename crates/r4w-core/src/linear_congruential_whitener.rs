//! Bit-level whitening/de-whitening using Linear Congruential Generator (LCG) sequences.
//!
//! This module provides stream data randomization via XOR with pseudo-random bit
//! sequences generated by a configurable LCG. Whitening ensures DC balance and
//! prevents long runs of identical bits, which is critical for clock recovery and
//! spectral compliance in digital communication systems.
//!
//! The LCG recurrence is: `x_{n+1} = (a * x_n + c) mod m`
//!
//! Since XOR is its own inverse, applying the same whitening sequence to whitened
//! data recovers the original — i.e., whitening and de-whitening are the same operation.
//!
//! # Example
//!
//! ```
//! use r4w_core::linear_congruential_whitener::LcgWhitener;
//!
//! let mut whitener = LcgWhitener::bluetooth();
//! let data = vec![0xAA, 0x55, 0xFF, 0x00];
//! let whitened = whitener.whiten_bytes(&data);
//!
//! // De-whitening is the same operation with a reset whitener
//! let mut dewhitener = LcgWhitener::bluetooth();
//! let recovered = dewhitener.whiten_bytes(&whitened);
//! assert_eq!(data, recovered);
//! ```

/// State snapshot for save/restore during streaming operation.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LcgState {
    /// Current LCG state value.
    pub state: u64,
    /// Number of steps advanced from the seed.
    pub steps: u64,
}

/// Bit-level whitener/de-whitener using a Linear Congruential Generator.
///
/// The LCG produces a pseudo-random sequence used to XOR with input data.
/// Because XOR is self-inverse, the same struct and parameters perform both
/// whitening and de-whitening.
#[derive(Debug, Clone)]
pub struct LcgWhitener {
    /// Multiplier.
    a: u64,
    /// Increment.
    c: u64,
    /// Modulus.
    m: u64,
    /// Current state.
    state: u64,
    /// Initial seed (for reset).
    seed: u64,
    /// Number of steps advanced.
    steps: u64,
}

impl LcgWhitener {
    /// Create a new LCG whitener with custom parameters.
    ///
    /// # Arguments
    /// * `a` - Multiplier
    /// * `c` - Increment
    /// * `m` - Modulus (must be > 0)
    /// * `seed` - Initial state
    ///
    /// # Panics
    /// Panics if `m` is zero.
    pub fn new(a: u64, c: u64, m: u64, seed: u64) -> Self {
        assert!(m > 0, "modulus m must be greater than zero");
        let seed_mod = seed % m;
        Self {
            a,
            c,
            m,
            state: seed_mod,
            seed: seed_mod,
            steps: 0,
        }
    }

    // -----------------------------------------------------------------------
    // Presets
    // -----------------------------------------------------------------------

    /// Bluetooth whitening preset.
    ///
    /// Uses parameters suited for Bluetooth baseband whitening:
    /// `a = 1103515245, c = 12345, m = 2^31`.
    pub fn bluetooth() -> Self {
        Self::new(1_103_515_245, 12_345, 1 << 31, 1)
    }

    /// DVB-S2 whitening preset.
    ///
    /// Parameters inspired by DVB-S2 stream adaptation:
    /// `a = 214013, c = 2531011, m = 2^32`.
    pub fn dvb_s2() -> Self {
        Self::new(214_013, 2_531_011, 1u64 << 32, 0x4A80)
    }

    /// IEEE 802.11 (Wi-Fi) scrambler-inspired preset.
    ///
    /// `a = 6364136223846793005, c = 1442695040888963407, m = 2^64`.
    /// Uses Knuth's constants for a full-period 64-bit LCG.
    pub fn wifi() -> Self {
        // m = 2^64, which in u64 arithmetic is 0 (wrapping). We use a special
        // sentinel: m = 0 means "use wrapping 2^64 arithmetic".
        Self {
            a: 6_364_136_223_846_793_005,
            c: 1_442_695_040_888_963_407,
            m: 0, // sentinel for 2^64
            state: 0x1D,
            seed: 0x1D,
            steps: 0,
        }
    }

    // -----------------------------------------------------------------------
    // Core LCG stepping
    // -----------------------------------------------------------------------

    /// Advance the LCG by one step and return the new state value.
    #[inline]
    fn step(&mut self) -> u64 {
        if self.m == 0 {
            // 2^64 wrapping arithmetic
            self.state = self.a.wrapping_mul(self.state).wrapping_add(self.c);
        } else {
            // Use u128 to prevent overflow for large a, state, c values.
            let next = ((self.a as u128) * (self.state as u128) + (self.c as u128)) % (self.m as u128);
            self.state = next as u64;
        }
        self.steps += 1;
        self.state
    }

    /// Extract a single pseudo-random bit from the current LCG output.
    ///
    /// Uses bit 16 of the state, which is in the higher-quality region of
    /// typical LCG outputs (low bits have short periods in power-of-2 moduli).
    #[inline]
    fn next_bit(&mut self) -> bool {
        let s = self.step();
        // Use bit 16 for better randomness than the LSB.
        (s >> 16) & 1 == 1
    }

    /// Generate the next pseudo-random byte (8 bits) from the LCG.
    fn next_byte(&mut self) -> u8 {
        let mut byte = 0u8;
        for i in 0..8 {
            if self.next_bit() {
                byte |= 1 << i;
            }
        }
        byte
    }

    // -----------------------------------------------------------------------
    // Whitening operations
    // -----------------------------------------------------------------------

    /// Whiten (or de-whiten) a slice of bits.
    ///
    /// Each input bit is XORed with the next LCG output bit.
    pub fn whiten_bits(&mut self, bits: &[bool]) -> Vec<bool> {
        bits.iter().map(|&b| b ^ self.next_bit()).collect()
    }

    /// Whiten (or de-whiten) a slice of bytes.
    ///
    /// Each input byte is XORed with an 8-bit pseudo-random mask from the LCG.
    pub fn whiten_bytes(&mut self, data: &[u8]) -> Vec<u8> {
        data.iter().map(|&b| b ^ self.next_byte()).collect()
    }

    /// Whiten bits in-place.
    pub fn whiten_bits_inplace(&mut self, bits: &mut [bool]) {
        for b in bits.iter_mut() {
            *b ^= self.next_bit();
        }
    }

    /// Whiten bytes in-place.
    pub fn whiten_bytes_inplace(&mut self, data: &mut [u8]) {
        for b in data.iter_mut() {
            *b ^= self.next_byte();
        }
    }

    // -----------------------------------------------------------------------
    // State management
    // -----------------------------------------------------------------------

    /// Reset the whitener to its initial seed state.
    pub fn reset(&mut self) {
        self.state = self.seed;
        self.steps = 0;
    }

    /// Save the current LCG state for later restoration.
    pub fn save_state(&self) -> LcgState {
        LcgState {
            state: self.state,
            steps: self.steps,
        }
    }

    /// Restore a previously saved LCG state.
    pub fn restore_state(&mut self, saved: &LcgState) {
        self.state = saved.state;
        self.steps = saved.steps;
    }

    /// Return the current internal state value.
    pub fn current_state(&self) -> u64 {
        self.state
    }

    /// Return the number of steps taken since the last reset.
    pub fn steps_taken(&self) -> u64 {
        self.steps
    }

    /// Return the LCG parameters `(a, c, m)`.
    pub fn parameters(&self) -> (u64, u64, u64) {
        (self.a, self.c, self.m)
    }

    // -----------------------------------------------------------------------
    // Analysis utilities
    // -----------------------------------------------------------------------

    /// Estimate the period length of the LCG sequence.
    ///
    /// Uses Floyd's cycle detection ("tortoise and hare") algorithm.
    /// Returns `None` if the period exceeds `max_steps`.
    pub fn estimate_period(&self, max_steps: u64) -> Option<u64> {
        let step_fn = |s: u64| -> u64 {
            if self.m == 0 {
                self.a.wrapping_mul(s).wrapping_add(self.c)
            } else {
                (((self.a as u128) * (s as u128) + (self.c as u128)) % (self.m as u128)) as u64
            }
        };

        // Phase 1: find a meeting point inside the cycle.
        let mut tortoise = step_fn(self.seed);
        let mut hare = step_fn(step_fn(self.seed));
        let mut count = 0u64;
        while tortoise != hare {
            tortoise = step_fn(tortoise);
            hare = step_fn(step_fn(hare));
            count += 1;
            if count > max_steps {
                return None;
            }
        }

        // Phase 2: find the start of the cycle.
        tortoise = self.seed;
        while tortoise != hare {
            tortoise = step_fn(tortoise);
            hare = step_fn(hare);
        }

        // Phase 3: measure the cycle length.
        let mut length = 1u64;
        hare = step_fn(tortoise);
        while tortoise != hare {
            hare = step_fn(hare);
            length += 1;
            if length > max_steps {
                return None;
            }
        }

        Some(length)
    }

    /// Measure the bit balance of the whitening sequence over `n` bits.
    ///
    /// Returns `(zeros, ones)` — the counts of 0-bits and 1-bits produced by
    /// the LCG. A well-balanced sequence has roughly equal counts.
    ///
    /// This method clones the whitener so the caller's state is not modified.
    pub fn bit_balance(&self, n: usize) -> (usize, usize) {
        let mut clone = self.clone();
        let mut ones = 0usize;
        for _ in 0..n {
            if clone.next_bit() {
                ones += 1;
            }
        }
        (n - ones, ones)
    }

    /// Compute the normalized autocorrelation of the whitening bit sequence at
    /// the given lags.
    ///
    /// The sequence is mapped to +1/-1 (0 -> +1, 1 -> -1) and autocorrelation
    /// is computed for each lag in `lags`. The values are normalized to the
    /// range [-1, 1]. Returns a vector of `(f64, f64)` tuples treated as
    /// (lag_index_as_f64, autocorrelation_value) so the result can be used
    /// directly as complex-number-style pairs per project convention.
    ///
    /// `n` is the number of sequence samples used for the estimate.
    ///
    /// This method clones the whitener so the caller's state is not modified.
    pub fn autocorrelation(&self, n: usize, lags: &[usize]) -> Vec<(f64, f64)> {
        let mut clone = self.clone();
        // Generate bipolar sequence: false -> +1.0, true -> -1.0
        let seq: Vec<f64> = (0..n)
            .map(|_| if clone.next_bit() { -1.0 } else { 1.0 })
            .collect();

        let energy: f64 = seq.iter().map(|&x| x * x).sum();
        if energy == 0.0 {
            return lags.iter().map(|&l| (l as f64, 0.0)).collect();
        }

        lags.iter()
            .map(|&lag| {
                if lag >= n {
                    return (lag as f64, 0.0);
                }
                let sum: f64 = (0..(n - lag)).map(|i| seq[i] * seq[i + lag]).sum();
                (lag as f64, sum / energy)
            })
            .collect()
    }

    /// Compute a simple statistical randomness quality metric for the whitening
    /// sequence over `n` bits.
    ///
    /// Returns a score in [0.0, 1.0] where 1.0 is ideal. The metric combines:
    /// - **Bit balance** (50% weight): deviation from 50/50 split.
    /// - **Run distribution** (25% weight): deviation from expected mean run length of 2.
    /// - **Autocorrelation** (25% weight): low lag-1 autocorrelation.
    ///
    /// This method clones the whitener so the caller's state is not modified.
    pub fn randomness_quality(&self, n: usize) -> f64 {
        if n == 0 {
            return 0.0;
        }

        let mut clone = self.clone();
        let bits: Vec<bool> = (0..n).map(|_| clone.next_bit()).collect();

        // --- Bit balance score ---
        let ones = bits.iter().filter(|&&b| b).count();
        let balance_ratio = ones as f64 / n as f64;
        // Perfect balance = 0.5; score = 1 - 2*|ratio - 0.5|, clamped to [0,1]
        let balance_score = (1.0 - 2.0 * (balance_ratio - 0.5).abs()).max(0.0);

        // --- Run length score ---
        // Mean run length for a fair coin is 2.0.
        let mut runs = 0usize;
        if !bits.is_empty() {
            runs = 1;
            for i in 1..bits.len() {
                if bits[i] != bits[i - 1] {
                    runs += 1;
                }
            }
        }
        let mean_run = n as f64 / runs.max(1) as f64;
        // Ideal mean_run ~ 2.0.  Score penalizes deviation.
        let run_score = (1.0 - (mean_run - 2.0).abs() / 2.0).max(0.0).min(1.0);

        // --- Autocorrelation score (lag 1) ---
        let bipolar: Vec<f64> = bits.iter().map(|&b| if b { -1.0 } else { 1.0 }).collect();
        let energy: f64 = bipolar.iter().map(|x| x * x).sum();
        let lag1: f64 = if n > 1 && energy > 0.0 {
            let s: f64 = (0..(n - 1)).map(|i| bipolar[i] * bipolar[i + 1]).sum();
            (s / energy).abs()
        } else {
            1.0
        };
        let autocorr_score = (1.0 - lag1).max(0.0).min(1.0);

        // Weighted combination
        0.50 * balance_score + 0.25 * run_score + 0.25 * autocorr_score
    }

    /// Generate `n` raw whitening bytes without any input data (useful for analysis).
    pub fn generate_sequence(&mut self, n: usize) -> Vec<u8> {
        (0..n).map(|_| self.next_byte()).collect()
    }

    /// Generate `n` raw whitening bits without any input data.
    pub fn generate_bit_sequence(&mut self, n: usize) -> Vec<bool> {
        (0..n).map(|_| self.next_bit()).collect()
    }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    // --- Construction & parameters ---

    #[test]
    fn test_new_custom_parameters() {
        let w = LcgWhitener::new(5, 3, 16, 7);
        assert_eq!(w.parameters(), (5, 3, 16));
        assert_eq!(w.current_state(), 7);
        assert_eq!(w.steps_taken(), 0);
    }

    #[test]
    fn test_seed_reduced_mod_m() {
        let w = LcgWhitener::new(1, 0, 10, 23);
        assert_eq!(w.current_state(), 3); // 23 % 10
    }

    #[test]
    #[should_panic(expected = "modulus m must be greater than zero")]
    fn test_zero_modulus_panics() {
        // m = 0 via the public constructor is invalid (0 is an internal
        // sentinel for 2^64 in the presets).
        LcgWhitener::new(1, 0, 0, 0);
    }

    // --- Presets ---

    #[test]
    fn test_bluetooth_preset() {
        let w = LcgWhitener::bluetooth();
        let (a, c, m) = w.parameters();
        assert_eq!(a, 1_103_515_245);
        assert_eq!(c, 12_345);
        assert_eq!(m, 1 << 31);
    }

    #[test]
    fn test_dvb_s2_preset() {
        let w = LcgWhitener::dvb_s2();
        let (a, c, m) = w.parameters();
        assert_eq!(a, 214_013);
        assert_eq!(c, 2_531_011);
        assert_eq!(m, 1u64 << 32);
    }

    #[test]
    fn test_wifi_preset() {
        let w = LcgWhitener::wifi();
        let (a, c, m) = w.parameters();
        assert_eq!(m, 0); // sentinel for 2^64
        assert!(a > 0);
        assert!(c > 0);
    }

    // --- Roundtrip (whiten then de-whiten) ---

    #[test]
    fn test_roundtrip_bytes_bluetooth() {
        let data = vec![0xDE, 0xAD, 0xBE, 0xEF, 0x01, 0x23, 0x45, 0x67];
        let mut w1 = LcgWhitener::bluetooth();
        let whitened = w1.whiten_bytes(&data);
        assert_ne!(whitened, data);

        let mut w2 = LcgWhitener::bluetooth();
        let recovered = w2.whiten_bytes(&whitened);
        assert_eq!(recovered, data);
    }

    #[test]
    fn test_roundtrip_bits() {
        let bits = vec![true, false, true, true, false, false, true, false];
        let mut w1 = LcgWhitener::new(13, 7, 256, 42);
        let whitened = w1.whiten_bits(&bits);

        let mut w2 = LcgWhitener::new(13, 7, 256, 42);
        let recovered = w2.whiten_bits(&whitened);
        assert_eq!(recovered, bits);
    }

    #[test]
    fn test_roundtrip_bytes_dvb_s2() {
        let data: Vec<u8> = (0..64).collect();
        let mut w1 = LcgWhitener::dvb_s2();
        let whitened = w1.whiten_bytes(&data);
        assert_ne!(whitened, data);

        let mut w2 = LcgWhitener::dvb_s2();
        let recovered = w2.whiten_bytes(&whitened);
        assert_eq!(recovered, data);
    }

    #[test]
    fn test_roundtrip_bytes_wifi() {
        let data = vec![0xFF; 32];
        let mut w1 = LcgWhitener::wifi();
        let whitened = w1.whiten_bytes(&data);

        let mut w2 = LcgWhitener::wifi();
        let recovered = w2.whiten_bytes(&whitened);
        assert_eq!(recovered, data);
    }

    // --- In-place whitening ---

    #[test]
    fn test_inplace_bytes() {
        let original = vec![0x12, 0x34, 0x56, 0x78];
        let mut data = original.clone();
        let mut w = LcgWhitener::bluetooth();
        w.whiten_bytes_inplace(&mut data);
        assert_ne!(data, original);

        // De-whiten in-place
        let mut w2 = LcgWhitener::bluetooth();
        w2.whiten_bytes_inplace(&mut data);
        assert_eq!(data, original);
    }

    #[test]
    fn test_inplace_bits() {
        let original = vec![false, true, true, false, true];
        let mut bits = original.clone();
        let mut w = LcgWhitener::new(7, 3, 128, 1);
        w.whiten_bits_inplace(&mut bits);

        let mut w2 = LcgWhitener::new(7, 3, 128, 1);
        w2.whiten_bits_inplace(&mut bits);
        assert_eq!(bits, original);
    }

    // --- State save/restore ---

    #[test]
    fn test_save_restore_state() {
        let mut w = LcgWhitener::bluetooth();
        // Advance a few steps
        let _ = w.generate_sequence(10);

        let saved = w.save_state();
        let bytes_a = w.generate_sequence(20);

        // Restore and regenerate -- must match.
        w.restore_state(&saved);
        let bytes_b = w.generate_sequence(20);
        assert_eq!(bytes_a, bytes_b);
    }

    #[test]
    fn test_reset() {
        let mut w = LcgWhitener::dvb_s2();
        let seq1 = w.generate_sequence(16);
        w.reset();
        let seq2 = w.generate_sequence(16);
        assert_eq!(seq1, seq2);
        assert_eq!(w.steps_taken(), 16 * 8); // 8 bits per byte
    }

    // --- Period estimation ---

    #[test]
    fn test_period_small_lcg() {
        // x_{n+1} = (5x + 3) mod 16, seed=0.  Full period LCG: period should be 16.
        let w = LcgWhitener::new(5, 3, 16, 0);
        let period = w.estimate_period(1000).unwrap();
        assert_eq!(period, 16);
    }

    #[test]
    fn test_period_returns_none_when_too_long() {
        let w = LcgWhitener::bluetooth();
        // With max_steps = 100, the Bluetooth LCG period (2^31) cannot be found.
        assert!(w.estimate_period(100).is_none());
    }

    // --- Bit balance ---

    #[test]
    fn test_bit_balance_reasonable() {
        let w = LcgWhitener::bluetooth();
        let (zeros, ones) = w.bit_balance(10_000);
        assert_eq!(zeros + ones, 10_000);
        // Expect roughly balanced: within 10% of 5000
        assert!((ones as f64 - 5000.0).abs() < 1000.0,
            "ones = {ones}, expected near 5000");
    }

    // --- Autocorrelation ---

    #[test]
    fn test_autocorrelation_lag_zero_is_one() {
        let w = LcgWhitener::bluetooth();
        let ac = w.autocorrelation(4096, &[0, 1, 2, 3]);
        // Lag 0 should always be 1.0
        assert!((ac[0].1 - 1.0).abs() < 1e-10, "lag-0 autocorrelation = {}", ac[0].1);
        // Non-zero lags should be low for a good sequence
        for &(lag, val) in &ac[1..] {
            assert!(val.abs() < 0.1, "autocorrelation at lag {lag} = {val}, expected < 0.1");
        }
    }

    // --- Randomness quality ---

    #[test]
    fn test_randomness_quality_bluetooth() {
        let w = LcgWhitener::bluetooth();
        let q = w.randomness_quality(10_000);
        assert!(q > 0.7, "Bluetooth quality = {q}, expected > 0.7");
    }

    #[test]
    fn test_randomness_quality_zero_length() {
        let w = LcgWhitener::bluetooth();
        assert_eq!(w.randomness_quality(0), 0.0);
    }

    // --- Sequence generation ---

    #[test]
    fn test_generate_sequence_length() {
        let mut w = LcgWhitener::bluetooth();
        let seq = w.generate_sequence(100);
        assert_eq!(seq.len(), 100);
    }

    #[test]
    fn test_generate_bit_sequence_length() {
        let mut w = LcgWhitener::bluetooth();
        let bits = w.generate_bit_sequence(256);
        assert_eq!(bits.len(), 256);
    }

    // --- Determinism ---

    #[test]
    fn test_deterministic_output() {
        let mut w1 = LcgWhitener::new(1103515245, 12345, 1 << 31, 42);
        let mut w2 = LcgWhitener::new(1103515245, 12345, 1 << 31, 42);
        let s1 = w1.generate_sequence(64);
        let s2 = w2.generate_sequence(64);
        assert_eq!(s1, s2);
    }

    // --- Edge cases ---

    #[test]
    fn test_empty_input() {
        let mut w = LcgWhitener::bluetooth();
        assert!(w.whiten_bytes(&[]).is_empty());
        assert!(w.whiten_bits(&[]).is_empty());
        assert_eq!(w.steps_taken(), 0);
    }

    #[test]
    fn test_whitening_changes_data() {
        // Whitened data should differ from the original (except in degenerate cases).
        let data = vec![0u8; 32];
        let mut w = LcgWhitener::bluetooth();
        let whitened = w.whiten_bytes(&data);
        // At least some bytes should differ
        assert!(whitened.iter().any(|&b| b != 0),
            "whitening all-zero data should produce non-zero output");
    }
}
