//! # Full-Duplex Self-Interference Canceller
//!
//! This module implements self-interference cancellation (SIC) for full-duplex
//! radios, suppressing TX leakage in the RX chain. Full-duplex operation
//! requires cancelling the transmitter's signal (which can be 80-120 dB stronger
//! than the desired received signal) across multiple stages:
//!
//! - **Analog cancellation**: RF-domain subtraction using a copy of the TX signal
//!   with estimated channel response applied.
//! - **Digital cancellation**: Baseband adaptive filtering using LMS with
//!   nonlinear basis expansion to model power amplifier distortion.
//!
//! The nonlinear model captures PA harmonics using basis functions of the form
//! `|x|^(2k) * x` for orders k=0,1,2,..., which represent the odd-order
//! intermodulation products generated by a memoryless PA model.
//!
//! # Example
//!
//! ```
//! use r4w_core::full_duplex_self_interference_canceller::{
//!     SelfInterferenceCanceller, CancellerConfig,
//! };
//!
//! // Configure a canceller with 16 taps and 3rd-order nonlinear model
//! let config = CancellerConfig {
//!     num_taps: 16,
//!     nonlinear_order: 3,
//!     step_size: 0.01,
//! };
//! let mut canceller = SelfInterferenceCanceller::new(config);
//!
//! // Suppose we have a known TX signal and a received signal with SI
//! let tx_signal: Vec<(f64, f64)> = (0..128)
//!     .map(|i| {
//!         let phase = i as f64 * 0.1;
//!         (phase.cos(), phase.sin())
//!     })
//!     .collect();
//!
//! // Simulate SI channel: scale + delay (simplified)
//! let rx_with_si: Vec<(f64, f64)> = tx_signal
//!     .iter()
//!     .map(|&(re, im)| (re * 0.5 + 0.01, im * 0.5 - 0.01))
//!     .collect();
//!
//! // Estimate the SI channel from known TX reference
//! canceller.estimate_channel(&tx_signal, &rx_with_si);
//!
//! // Cancel the interference
//! let cleaned = canceller.cancel(&tx_signal, &rx_with_si);
//!
//! // Measure suppression
//! let depth = canceller.cancellation_depth_db(&rx_with_si, &cleaned);
//! assert!(depth > 10.0, "Expected >10 dB cancellation, got {:.1} dB", depth);
//! ```

use std::f64::consts::PI;

// ─── Complex arithmetic helpers ────────────────────────────────────────────

/// Complex type alias for readability.
type C64 = (f64, f64);

#[inline]
fn c_add(a: C64, b: C64) -> C64 {
    (a.0 + b.0, a.1 + b.1)
}

#[inline]
fn c_sub(a: C64, b: C64) -> C64 {
    (a.0 - b.0, a.1 - b.1)
}

#[inline]
fn c_mul(a: C64, b: C64) -> C64 {
    (a.0 * b.0 - a.1 * b.1, a.0 * b.1 + a.1 * b.0)
}

#[inline]
fn c_conj(a: C64) -> C64 {
    (a.0, -a.1)
}

#[inline]
fn c_scale(a: C64, s: f64) -> C64 {
    (a.0 * s, a.1 * s)
}

#[inline]
fn c_mag_sq(a: C64) -> f64 {
    a.0 * a.0 + a.1 * a.1
}

#[inline]
fn c_mag(a: C64) -> f64 {
    c_mag_sq(a).sqrt()
}

// ─── Configuration ─────────────────────────────────────────────────────────

/// Configuration for the self-interference canceller.
#[derive(Debug, Clone)]
pub struct CancellerConfig {
    /// Number of FIR taps for the SI channel model.
    pub num_taps: usize,
    /// Nonlinear order for PA model (1 = linear only, 2-5 for PA harmonics).
    /// Order N uses basis functions: x, |x|²x, |x|⁴x, ... up to |x|^(2(N-1))x.
    pub nonlinear_order: usize,
    /// LMS step size (learning rate) for adaptive cancellation.
    pub step_size: f64,
}

impl Default for CancellerConfig {
    fn default() -> Self {
        Self {
            num_taps: 32,
            nonlinear_order: 3,
            step_size: 0.005,
        }
    }
}

// ─── Statistics ────────────────────────────────────────────────────────────

/// Statistics from a cancellation run.
#[derive(Debug, Clone)]
pub struct SicStatistics {
    /// Achieved cancellation depth in dB.
    pub cancellation_db: f64,
    /// Residual signal-to-interference ratio in dB.
    pub residual_sir: f64,
    /// Number of iterations (samples processed) during adaptive cancellation.
    pub iterations: usize,
}

// ─── Cancellation stages ───────────────────────────────────────────────────

/// Result of analog-stage cancellation.
#[derive(Debug, Clone)]
pub struct AnalogCancelResult {
    /// Signal after analog cancellation.
    pub signal: Vec<C64>,
    /// Estimated suppression in dB.
    pub suppression_db: f64,
}

// ─── Main struct ───────────────────────────────────────────────────────────

/// Self-interference canceller for full-duplex radios.
///
/// Models the SI channel as a nonlinear FIR filter and adaptively cancels
/// the TX leakage from the received signal.
pub struct SelfInterferenceCanceller {
    config: CancellerConfig,
    /// Filter weights: `[nonlinear_order][num_taps]` stored flat.
    /// Index: order * num_taps + tap.
    weights: Vec<C64>,
    /// Analog-stage weights (linear only, single tap set).
    analog_weights: Vec<C64>,
    /// Running statistics.
    total_iterations: usize,
}

impl SelfInterferenceCanceller {
    /// Create a new canceller with the given configuration.
    pub fn new(config: CancellerConfig) -> Self {
        let total_weights = config.nonlinear_order * config.num_taps;
        Self {
            weights: vec![(0.0, 0.0); total_weights],
            analog_weights: vec![(0.0, 0.0); config.num_taps],
            total_iterations: 0,
            config,
        }
    }

    /// Total number of adaptive filter weights.
    fn total_taps(&self) -> usize {
        self.config.nonlinear_order * self.config.num_taps
    }

    // ── Nonlinear basis expansion ──────────────────────────────────────

    /// Expand a single TX sample into nonlinear basis terms.
    /// Returns `[x, |x|²·x, |x|⁴·x, ...]` up to the configured order.
    fn nonlinear_basis(&self, x: C64) -> Vec<C64> {
        let mut basis = Vec::with_capacity(self.config.nonlinear_order);
        let mut power_factor = 1.0; // |x|^(2k) for k=0,1,...
        let mag_sq = c_mag_sq(x);
        for _ in 0..self.config.nonlinear_order {
            basis.push(c_scale(x, power_factor));
            power_factor *= mag_sq;
        }
        basis
    }

    /// Build the extended regressor vector for sample index `n` from a TX
    /// signal buffer. Returns a vector of length `nonlinear_order * num_taps`.
    fn build_regressor(&self, tx: &[C64], n: usize) -> Vec<C64> {
        let nt = self.config.num_taps;
        let no = self.config.nonlinear_order;
        let mut reg = vec![(0.0, 0.0); nt * no];
        for tap in 0..nt {
            let sample = if n >= tap { tx[n - tap] } else { (0.0, 0.0) };
            let basis = self.nonlinear_basis(sample);
            for (order, b) in basis.into_iter().enumerate() {
                reg[order * nt + tap] = b;
            }
        }
        reg
    }

    /// Compute the filter output (estimated SI) for sample index `n`.
    fn filter_output(&self, tx: &[C64], n: usize) -> C64 {
        let reg = self.build_regressor(tx, n);
        let mut y = (0.0, 0.0);
        for (w, r) in self.weights.iter().zip(reg.iter()) {
            y = c_add(y, c_mul(*w, *r));
        }
        y
    }

    // ── Public API ─────────────────────────────────────────────────────

    /// Estimate the SI channel from known TX and RX signals using
    /// block LMS (multiple passes over the data).
    pub fn estimate_channel(&mut self, tx: &[C64], rx: &[C64]) {
        let n = tx.len().min(rx.len());
        if n == 0 {
            return;
        }
        // Run several passes for convergence.
        let passes = 10;
        for _ in 0..passes {
            for i in 0..n {
                let y_hat = self.filter_output(tx, i);
                let err = c_sub(rx[i], y_hat);
                let reg = self.build_regressor(tx, i);
                // LMS weight update: w += mu * err * conj(reg)
                let mu = self.config.step_size;
                for (w, r) in self.weights.iter_mut().zip(reg.iter()) {
                    let update = c_mul(c_scale(err, mu), c_conj(*r));
                    *w = c_add(*w, update);
                }
            }
        }
    }

    /// Cancel self-interference: subtract estimated SI from the RX signal.
    pub fn cancel(&self, tx: &[C64], rx: &[C64]) -> Vec<C64> {
        let n = tx.len().min(rx.len());
        (0..n)
            .map(|i| {
                let si_est = self.filter_output(tx, i);
                c_sub(rx[i], si_est)
            })
            .collect()
    }

    /// Perform online adaptive cancellation using LMS.
    ///
    /// Processes the RX signal sample-by-sample, updating the filter
    /// weights adaptively. Returns the cleaned signal and statistics.
    pub fn adaptive_cancel(&mut self, tx: &[C64], rx: &[C64]) -> (Vec<C64>, SicStatistics) {
        let n = tx.len().min(rx.len());
        let mut output = Vec::with_capacity(n);
        let rx_power: f64 = rx.iter().map(|s| c_mag_sq(*s)).sum::<f64>() / n.max(1) as f64;

        for i in 0..n {
            let y_hat = self.filter_output(tx, i);
            let err = c_sub(rx[i], y_hat);
            output.push(err);

            // LMS update
            let reg = self.build_regressor(tx, i);
            let mu = self.config.step_size;
            // Normalized LMS: scale step size by regressor power
            let reg_power: f64 = reg.iter().map(|r| c_mag_sq(*r)).sum::<f64>();
            let norm_mu = if reg_power > 1e-12 {
                mu / (reg_power + 1e-8)
            } else {
                mu
            };
            for (w, r) in self.weights.iter_mut().zip(reg.iter()) {
                let update = c_mul(c_scale(err, norm_mu), c_conj(*r));
                *w = c_add(*w, update);
            }
            self.total_iterations += 1;
        }

        let residual_pwr = self.residual_power(&output);
        let canc_db = if rx_power > 1e-30 && residual_pwr > 1e-30 {
            10.0 * (rx_power / residual_pwr).log10()
        } else {
            0.0
        };

        let stats = SicStatistics {
            cancellation_db: canc_db,
            residual_sir: canc_db,
            iterations: n,
        };
        (output, stats)
    }

    /// Analog cancellation stage: applies a simple linear FIR model to
    /// produce an RF-domain cancellation signal.
    pub fn analog_cancel(&mut self, tx: &[C64], rx: &[C64]) -> AnalogCancelResult {
        let n = tx.len().min(rx.len());
        if n == 0 {
            return AnalogCancelResult {
                signal: vec![],
                suppression_db: 0.0,
            };
        }

        // Estimate analog weights using LMS (linear only)
        let nt = self.config.num_taps;
        let mu = self.config.step_size;
        for _ in 0..5 {
            for i in 0..n {
                // Compute analog filter output
                let mut y_hat = (0.0, 0.0);
                for tap in 0..nt {
                    let s = if i >= tap { tx[i - tap] } else { (0.0, 0.0) };
                    y_hat = c_add(y_hat, c_mul(self.analog_weights[tap], s));
                }
                let err = c_sub(rx[i], y_hat);
                for tap in 0..nt {
                    let s = if i >= tap { tx[i - tap] } else { (0.0, 0.0) };
                    let update = c_mul(c_scale(err, mu), c_conj(s));
                    self.analog_weights[tap] = c_add(self.analog_weights[tap], update);
                }
            }
        }

        // Apply analog cancellation
        let rx_power: f64 = rx.iter().map(|s| c_mag_sq(*s)).sum::<f64>();
        let mut signal = Vec::with_capacity(n);
        for i in 0..n {
            let mut y_hat = (0.0, 0.0);
            for tap in 0..nt {
                let s = if i >= tap { tx[i - tap] } else { (0.0, 0.0) };
                y_hat = c_add(y_hat, c_mul(self.analog_weights[tap], s));
            }
            signal.push(c_sub(rx[i], y_hat));
        }

        let res_power: f64 = signal.iter().map(|s| c_mag_sq(*s)).sum::<f64>();
        let suppression_db = if rx_power > 1e-30 && res_power > 1e-30 {
            10.0 * (rx_power / res_power).log10()
        } else {
            0.0
        };

        AnalogCancelResult {
            signal,
            suppression_db,
        }
    }

    /// Measure cancellation depth in dB between original and cleaned signals.
    pub fn cancellation_depth_db(&self, original: &[C64], cleaned: &[C64]) -> f64 {
        let n = original.len().min(cleaned.len());
        if n == 0 {
            return 0.0;
        }
        let orig_power: f64 = original.iter().take(n).map(|s| c_mag_sq(*s)).sum::<f64>();
        let clean_power: f64 = cleaned.iter().take(n).map(|s| c_mag_sq(*s)).sum::<f64>();
        if clean_power < 1e-30 {
            return 120.0; // Essentially perfect cancellation
        }
        10.0 * (orig_power / clean_power).log10()
    }

    /// Compute the average power of the residual signal.
    pub fn residual_power(&self, signal: &[C64]) -> f64 {
        if signal.is_empty() {
            return 0.0;
        }
        signal.iter().map(|s| c_mag_sq(*s)).sum::<f64>() / signal.len() as f64
    }

    /// Reset all filter weights and internal state.
    pub fn reset(&mut self) {
        for w in self.weights.iter_mut() {
            *w = (0.0, 0.0);
        }
        for w in self.analog_weights.iter_mut() {
            *w = (0.0, 0.0);
        }
        self.total_iterations = 0;
    }

    /// Return a reference to the current digital cancellation weights.
    pub fn weights(&self) -> &[C64] {
        &self.weights
    }

    /// Return the current configuration.
    pub fn config(&self) -> &CancellerConfig {
        &self.config
    }

    /// Return total iterations processed so far.
    pub fn total_iterations(&self) -> usize {
        self.total_iterations
    }
}

// ─── Tests ─────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    /// Helper: generate a complex sinusoid.
    fn tone(len: usize, freq: f64) -> Vec<C64> {
        (0..len)
            .map(|i| {
                let phase = 2.0 * PI * freq * i as f64;
                (phase.cos(), phase.sin())
            })
            .collect()
    }

    /// Helper: apply a simple 1-tap SI channel (scale + phase shift).
    fn apply_si_channel(tx: &[C64], gain: f64, phase: f64) -> Vec<C64> {
        let h = (gain * phase.cos(), gain * phase.sin());
        tx.iter().map(|&s| c_mul(h, s)).collect()
    }

    /// Helper: add two signals element-wise.
    fn add_signals(a: &[C64], b: &[C64]) -> Vec<C64> {
        a.iter()
            .zip(b.iter())
            .map(|(&x, &y)| c_add(x, y))
            .collect()
    }

    #[test]
    fn test_default_config() {
        let cfg = CancellerConfig::default();
        assert_eq!(cfg.num_taps, 32);
        assert_eq!(cfg.nonlinear_order, 3);
        assert!((cfg.step_size - 0.005).abs() < 1e-10);
    }

    #[test]
    fn test_new_canceller_zero_weights() {
        let canceller = SelfInterferenceCanceller::new(CancellerConfig::default());
        for w in canceller.weights() {
            assert_eq!(*w, (0.0, 0.0));
        }
    }

    #[test]
    fn test_weight_count() {
        let config = CancellerConfig {
            num_taps: 8,
            nonlinear_order: 3,
            step_size: 0.01,
        };
        let canceller = SelfInterferenceCanceller::new(config);
        assert_eq!(canceller.weights().len(), 8 * 3);
    }

    #[test]
    fn test_estimate_and_cancel_linear() {
        // Simple 1-tap linear SI channel
        let config = CancellerConfig {
            num_taps: 4,
            nonlinear_order: 1,
            step_size: 0.02,
        };
        let mut canceller = SelfInterferenceCanceller::new(config);

        let tx = tone(256, 0.05);
        let si = apply_si_channel(&tx, 0.8, 0.3);

        // RX = SI (no desired signal for simplicity)
        canceller.estimate_channel(&tx, &si);
        let cleaned = canceller.cancel(&tx, &si);

        let depth = canceller.cancellation_depth_db(&si, &cleaned);
        assert!(
            depth > 15.0,
            "Linear cancellation should achieve >15 dB, got {:.1} dB",
            depth
        );
    }

    #[test]
    fn test_adaptive_cancel_converges() {
        let config = CancellerConfig {
            num_taps: 8,
            nonlinear_order: 1,
            step_size: 0.01,
        };
        let mut canceller = SelfInterferenceCanceller::new(config);

        let tx = tone(512, 0.03);
        let si = apply_si_channel(&tx, 0.5, 0.0);

        let (cleaned, stats) = canceller.adaptive_cancel(&tx, &si);
        assert_eq!(stats.iterations, 512);
        assert!(
            stats.cancellation_db > 5.0,
            "Adaptive should converge, got {:.1} dB",
            stats.cancellation_db
        );

        // Check residual power is less than original
        let orig_pwr = canceller.residual_power(&si);
        let res_pwr = canceller.residual_power(&cleaned);
        assert!(res_pwr < orig_pwr, "Residual power should decrease");
    }

    #[test]
    fn test_nonlinear_cancellation() {
        let config = CancellerConfig {
            num_taps: 8,
            nonlinear_order: 3,
            step_size: 0.01,
        };
        let mut canceller = SelfInterferenceCanceller::new(config);

        // TX signal
        let tx = tone(256, 0.04);

        // Nonlinear SI channel: h0*x + h1*|x|^2*x (3rd-order intermod)
        let si: Vec<C64> = tx
            .iter()
            .map(|&x| {
                let linear = c_scale(x, 0.6);
                let cubic = c_scale(x, 0.1 * c_mag_sq(x));
                c_add(linear, cubic)
            })
            .collect();

        canceller.estimate_channel(&tx, &si);
        let cleaned = canceller.cancel(&tx, &si);
        let depth = canceller.cancellation_depth_db(&si, &cleaned);

        assert!(
            depth > 10.0,
            "Nonlinear cancellation should work, got {:.1} dB",
            depth
        );
    }

    #[test]
    fn test_reset_clears_state() {
        let config = CancellerConfig {
            num_taps: 4,
            nonlinear_order: 2,
            step_size: 0.01,
        };
        let mut canceller = SelfInterferenceCanceller::new(config);

        // Train with some data
        let tx = tone(128, 0.1);
        let si = apply_si_channel(&tx, 0.5, 0.0);
        canceller.estimate_channel(&tx, &si);

        // Verify weights are nonzero
        let has_nonzero = canceller.weights().iter().any(|w| c_mag(*w) > 1e-10);
        assert!(has_nonzero, "Weights should be nonzero after training");

        // Reset
        canceller.reset();
        for w in canceller.weights() {
            assert_eq!(*w, (0.0, 0.0), "Weights should be zero after reset");
        }
        assert_eq!(canceller.total_iterations(), 0);
    }

    #[test]
    fn test_cancellation_depth_perfect() {
        let canceller = SelfInterferenceCanceller::new(CancellerConfig::default());
        let signal = tone(64, 0.1);
        let zero_signal: Vec<C64> = vec![(0.0, 0.0); 64];
        let depth = canceller.cancellation_depth_db(&signal, &zero_signal);
        assert!(
            depth >= 100.0,
            "Perfect cancellation should give high dB, got {:.1}",
            depth
        );
    }

    #[test]
    fn test_residual_power_zero_signal() {
        let canceller = SelfInterferenceCanceller::new(CancellerConfig::default());
        let zero: Vec<C64> = vec![(0.0, 0.0); 32];
        let pwr = canceller.residual_power(&zero);
        assert!((pwr).abs() < 1e-30, "Zero signal should have zero power");
    }

    #[test]
    fn test_residual_power_known() {
        let canceller = SelfInterferenceCanceller::new(CancellerConfig::default());
        // Signal with known power: (1, 0) has |x|^2 = 1
        let signal: Vec<C64> = vec![(1.0, 0.0); 100];
        let pwr = canceller.residual_power(&signal);
        assert!(
            (pwr - 1.0).abs() < 1e-10,
            "Power of unit signal should be 1.0, got {}",
            pwr
        );
    }

    #[test]
    fn test_analog_cancel() {
        let config = CancellerConfig {
            num_taps: 4,
            nonlinear_order: 1,
            step_size: 0.02,
        };
        let mut canceller = SelfInterferenceCanceller::new(config);

        let tx = tone(256, 0.05);
        let si = apply_si_channel(&tx, 0.7, 0.2);

        let result = canceller.analog_cancel(&tx, &si);
        assert_eq!(result.signal.len(), 256);
        assert!(
            result.suppression_db > 10.0,
            "Analog stage should suppress >10 dB, got {:.1} dB",
            result.suppression_db
        );
    }

    #[test]
    fn test_two_stage_cancellation() {
        // Analog + digital stages should outperform either alone
        let config = CancellerConfig {
            num_taps: 8,
            nonlinear_order: 2,
            step_size: 0.01,
        };
        let mut canceller = SelfInterferenceCanceller::new(config);

        let tx = tone(512, 0.04);
        let si = apply_si_channel(&tx, 0.9, 0.5);

        // Desired signal (weak)
        let desired = tone(512, 0.2);
        let desired_weak: Vec<C64> = desired.iter().map(|&s| c_scale(s, 0.01)).collect();
        let rx = add_signals(&si, &desired_weak);

        // Stage 1: analog
        let analog_result = canceller.analog_cancel(&tx, &rx);

        // Stage 2: digital (adaptive) on the residual from analog stage
        let mut canceller2 = SelfInterferenceCanceller::new(CancellerConfig {
            num_taps: 8,
            nonlinear_order: 2,
            step_size: 0.01,
        });
        let (final_cleaned, _stats) = canceller2.adaptive_cancel(&tx, &analog_result.signal);

        // Overall suppression from original rx to final output
        let overall_depth = canceller.cancellation_depth_db(&rx, &final_cleaned);
        assert!(
            overall_depth > 5.0,
            "Two-stage cancellation should provide substantial suppression, got {:.1} dB",
            overall_depth
        );
    }

    #[test]
    fn test_empty_signals() {
        let config = CancellerConfig {
            num_taps: 4,
            nonlinear_order: 1,
            step_size: 0.01,
        };
        let mut canceller = SelfInterferenceCanceller::new(config);

        let empty: Vec<C64> = vec![];
        canceller.estimate_channel(&empty, &empty);
        let cleaned = canceller.cancel(&empty, &empty);
        assert!(cleaned.is_empty());

        let depth = canceller.cancellation_depth_db(&empty, &empty);
        assert_eq!(depth, 0.0);

        let pwr = canceller.residual_power(&empty);
        assert_eq!(pwr, 0.0);
    }

    #[test]
    fn test_sic_statistics_fields() {
        let stats = SicStatistics {
            cancellation_db: 25.0,
            residual_sir: 30.0,
            iterations: 1024,
        };
        assert!((stats.cancellation_db - 25.0).abs() < 1e-10);
        assert!((stats.residual_sir - 30.0).abs() < 1e-10);
        assert_eq!(stats.iterations, 1024);
    }

    #[test]
    fn test_nonlinear_basis_expansion() {
        let config = CancellerConfig {
            num_taps: 4,
            nonlinear_order: 3,
            step_size: 0.01,
        };
        let canceller = SelfInterferenceCanceller::new(config);

        let x: C64 = (0.5, 0.3);
        let basis = canceller.nonlinear_basis(x);
        assert_eq!(basis.len(), 3);

        // Order 0: x itself
        assert!((basis[0].0 - x.0).abs() < 1e-12);
        assert!((basis[0].1 - x.1).abs() < 1e-12);

        // Order 1: |x|^2 * x
        let mag_sq = c_mag_sq(x);
        let expected_1 = c_scale(x, mag_sq);
        assert!((basis[1].0 - expected_1.0).abs() < 1e-12);
        assert!((basis[1].1 - expected_1.1).abs() < 1e-12);

        // Order 2: |x|^4 * x
        let expected_2 = c_scale(x, mag_sq * mag_sq);
        assert!((basis[2].0 - expected_2.0).abs() < 1e-12);
        assert!((basis[2].1 - expected_2.1).abs() < 1e-12);
    }
}
