//! Linear Feedback Shift Register (LFSR) for M-Sequence Generation
//!
//! M-sequences (maximum-length sequences) are generated by LFSRs and have
//! the property that they cycle through all 2^n - 1 non-zero states.
//!
//! ## Properties
//!
//! - Length: 2^n - 1 where n is the register length
//! - Balance: (2^(n-1)) ones and (2^(n-1) - 1) zeros
//! - Autocorrelation: Peak at lag 0, -1 at all other lags
//!
//! ## Common Polynomials
//!
//! | Degree | Length | Polynomial (hex) | Polynomial |
//! |--------|--------|------------------|------------|
//! | 5      | 31     | 0x25             | x^5 + x^2 + 1 |
//! | 6      | 63     | 0x43             | x^6 + x + 1 |
//! | 7      | 127    | 0x83             | x^7 + x + 1 |
//! | 8      | 255    | 0x11D            | x^8 + x^4 + x^3 + x^2 + 1 |
//! | 9      | 511    | 0x211            | x^9 + x^4 + 1 |
//! | 10     | 1023   | 0x409            | x^10 + x^3 + 1 |

use super::PnSequence;

/// Linear Feedback Shift Register
#[derive(Debug, Clone)]
pub struct Lfsr {
    /// Current state of the register
    state: u32,
    /// Feedback polynomial (taps)
    polynomial: u32,
    /// Number of bits in the register
    degree: u8,
    /// Initial state for reset
    initial_state: u32,
}

impl Lfsr {
    /// Create a new LFSR
    ///
    /// # Arguments
    /// - `degree`: Number of bits (determines sequence length 2^n - 1)
    /// - `polynomial`: Feedback polynomial as integer (e.g., 0x83 for x^7 + x + 1)
    /// - `initial_state`: Starting state (must be non-zero)
    pub fn new(degree: u8, polynomial: u32, initial_state: u32) -> Self {
        assert!(degree >= 2 && degree <= 31, "Degree must be 2-31");
        assert!(initial_state != 0, "Initial state must be non-zero");

        Self {
            state: initial_state,
            polynomial,
            degree,
            initial_state,
        }
    }

    /// Clock the LFSR and return the output bit (Fibonacci LFSR)
    pub fn clock(&mut self) -> u8 {
        // Output is the MSB (highest bit)
        let output = ((self.state >> (self.degree - 1)) & 1) as u8;

        // Calculate feedback (XOR of tapped bits including the output bit)
        // The polynomial defines which bits to XOR
        let feedback = (self.state & self.polynomial).count_ones() & 1;

        // Shift left and insert feedback at LSB
        let mask = (1u32 << self.degree) - 1; // Mask to keep only 'degree' bits
        self.state = ((self.state << 1) | feedback) & mask;

        output
    }

    /// Get the current state
    pub fn state(&self) -> u32 {
        self.state
    }

    /// Get the output of a specific tap position (1-based, where 1 is LSB)
    /// Used by GPS C/A code generation which needs intermediate tap outputs from G2
    pub fn tap_output(&self, tap: u8) -> u8 {
        ((self.state >> (tap - 1)) & 1) as u8
    }

    /// Get the degree of this LFSR
    pub fn degree(&self) -> u8 {
        self.degree
    }

    /// Set the state directly (for synchronization)
    pub fn set_state(&mut self, state: u32) {
        assert!(state != 0, "State must be non-zero");
        self.state = state;
    }
}

/// M-Sequence generator (wrapper around LFSR that outputs +1/-1)
#[derive(Debug, Clone)]
pub struct MSequence {
    lfsr: Lfsr,
}

impl MSequence {
    /// Create a new M-sequence generator
    pub fn new(degree: u8, polynomial: u32, initial_state: u32) -> Self {
        Self {
            lfsr: Lfsr::new(degree, polynomial, initial_state),
        }
    }

    /// Create with common polynomials by degree
    pub fn from_degree(degree: u8) -> Self {
        let polynomial = match degree {
            3 => 0x05,   // x^3 + x^2 + 1
            4 => 0x09,   // x^4 + x^3 + 1
            5 => 0x12,   // x^5 + x^2 + 1
            6 => 0x21,   // x^6 + x^5 + 1
            7 => 0x41,   // x^7 + x^6 + 1 (alternative: 0x83)
            8 => 0x8E,   // x^8 + x^4 + x^3 + x^2 + 1
            9 => 0x108,  // x^9 + x^4 + 1
            10 => 0x204, // x^10 + x^3 + 1
            _ => panic!("No default polynomial for degree {}", degree),
        };
        Self::new(degree, polynomial, 0x01)
    }

    /// Get the underlying LFSR
    pub fn lfsr(&self) -> &Lfsr {
        &self.lfsr
    }

    /// Get the underlying LFSR mutably
    pub fn lfsr_mut(&mut self) -> &mut Lfsr {
        &mut self.lfsr
    }
}

impl PnSequence for MSequence {
    fn next_chip(&mut self) -> i8 {
        // Convert 0/1 to +1/-1 (BPSK mapping)
        if self.lfsr.clock() == 0 {
            1
        } else {
            -1
        }
    }

    fn reset(&mut self) {
        self.lfsr.state = self.lfsr.initial_state;
    }

    fn length(&self) -> usize {
        (1 << self.lfsr.degree) - 1
    }
}

/// Preferred pairs of polynomials for Gold code generation
pub const GOLD_PREFERRED_PAIRS: &[(u8, u32, u32)] = &[
    // (degree, poly_a, poly_b)
    (5, 0x12, 0x1E),   // Length 31
    (6, 0x21, 0x33),   // Length 63
    (7, 0x41, 0x47),   // Length 127
    (8, 0x8E, 0xAE),   // Length 255
    (9, 0x108, 0x130), // Length 511
    (10, 0x204, 0x327), // Length 1023
];

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lfsr_period() {
        let mut lfsr = Lfsr::new(5, 0x12, 0x01);
        let initial = lfsr.state();

        // Should return to initial state after 2^5 - 1 = 31 clocks
        for _ in 0..31 {
            lfsr.clock();
        }
        assert_eq!(lfsr.state(), initial);
    }

    #[test]
    fn test_msequence_length() {
        let mseq = MSequence::new(7, 0x41, 0x01);
        assert_eq!(mseq.length(), 127);
    }

    #[test]
    fn test_msequence_balance() {
        let mut mseq = MSequence::from_degree(5);
        let seq = mseq.generate_sequence();

        // M-sequence of length 2^n - 1 has:
        // - 2^(n-1) ones (in binary) → become -1 in our mapping
        // - 2^(n-1) - 1 zeros (in binary) → become +1 in our mapping
        // For n=5: 16 ones (-1) and 15 zeros (+1), sum = 15 - 16 = -1
        let sum: i32 = seq.iter().map(|&x| x as i32).sum();
        assert_eq!(sum, -1); // M-sequences always have sum of -1

        assert_eq!(seq.len(), 31);
    }

    #[test]
    fn test_msequence_autocorrelation() {
        let mut mseq = MSequence::from_degree(5);
        let seq = mseq.generate_sequence();

        // Peak at lag 0
        let peak: i32 = seq.iter().map(|&x| (x as i32) * (x as i32)).sum();
        assert_eq!(peak, 31);

        // Off-peak should be -1 for m-sequences
        let off_peak: i32 = seq
            .iter()
            .enumerate()
            .map(|(i, &x)| (x as i32) * (seq[(i + 1) % 31] as i32))
            .sum();
        assert_eq!(off_peak, -1);
    }
}
