//! Dam Seepage and Structural Integrity Monitor.
//!
//! Monitors dam structural integrity via piezometer readings, seepage flow rates,
//! and uplift pressures. Detects anomalous seepage patterns indicating potential
//! dam failure through hydraulic gradient analysis, Lugeon permeability testing,
//! phreatic surface validation, and piping risk assessment.
//!
//! # Background
//!
//! Dam safety monitoring relies on continuous measurement of pore water pressures
//! (piezometers), seepage flow rates (weirs/flumes), and uplift pressures beneath
//! the dam foundation. Key failure modes include:
//!
//! - **Piping**: Internal erosion caused by excessive hydraulic gradients
//! - **Uplift**: Excessive pore pressure reducing effective weight
//! - **Overtopping**: Phreatic surface intersecting the downstream face
//! - **Slope instability**: Insufficient factor of safety against sliding
//!
//! # Example
//!
//! ```
//! use r4w_core::dam_seepage_monitor::{
//!     DamConfig, SeepageMonitor, uplift_pressure_ratio, factor_of_safety,
//! };
//!
//! let config = DamConfig {
//!     dam_height_m: 30.0,
//!     num_piezometers: 4,
//!     reservoir_level_m: 28.0,
//!     drain_efficiency: 0.6,
//! };
//! let mut monitor = SeepageMonitor::new(config);
//!
//! let piezometer_levels = [20.0, 15.0, 10.0, 5.0];
//! let flow_rates = [0.5, 0.6, 0.55, 0.52];
//! let status = monitor.process_readings(&piezometer_levels, &flow_rates);
//!
//! assert!(status.safety_factor > 1.0);
//! assert!(status.uplift_pressure_ratio < 1.0);
//!
//! let ratio = uplift_pressure_ratio(150_000.0, 294_300.0);
//! assert!((ratio - 0.51).abs() < 0.01);
//!
//! let fos = factor_of_safety(2_000_000.0, 1_000_000.0);
//! assert!((fos - 2.0).abs() < 1e-9);
//! ```

/// Density of water in kg/m^3.
const WATER_DENSITY: f64 = 1000.0;

/// Gravitational acceleration in m/s^2.
const GRAVITY: f64 = 9.81;

/// Default void ratio for critical gradient calculation when not specified.
const DEFAULT_VOID_RATIO: f64 = 0.65;

/// Pressure threshold ratio above which an ExcessivePressure alert is generated.
const PRESSURE_ALERT_THRESHOLD: f64 = 0.7;

/// Flow rate change threshold (fraction) for AbnormalFlow alerts.
const FLOW_ALERT_THRESHOLD: f64 = 0.3;

/// Hydraulic gradient threshold for piping risk (Terzaghi critical gradient ~1.0).
const PIPING_GRADIENT_THRESHOLD: f64 = 0.8;

/// Uplift pressure ratio threshold for UpliftExceeded alerts.
const UPLIFT_ALERT_THRESHOLD: f64 = 0.6;

/// Minimum number of readings to compute a trend.
const MIN_TREND_SAMPLES: usize = 3;

/// Slope magnitude threshold for classifying a trend as Increasing or Decreasing.
const TREND_SLOPE_THRESHOLD: f64 = 0.01;

/// R-squared threshold below which a trend is classified as Erratic.
const TREND_R2_THRESHOLD: f64 = 0.3;

/// Phreatic surface safety margin as a fraction of dam height.
/// The phreatic surface must remain below (1 - margin) * dam_height on the
/// downstream face to be considered safe.
const PHREATIC_SAFETY_MARGIN: f64 = 0.33;

/// Configuration for a dam monitoring installation.
#[derive(Debug, Clone)]
pub struct DamConfig {
    /// Total height of the dam in meters.
    pub dam_height_m: f64,
    /// Number of piezometer instruments installed.
    pub num_piezometers: usize,
    /// Current reservoir water level in meters (measured from dam base).
    pub reservoir_level_m: f64,
    /// Drain efficiency factor in [0, 1]. A value of 1.0 means drains are
    /// perfectly effective at relieving uplift pressure; 0.0 means no drains.
    pub drain_efficiency: f64,
}

/// Alert types for dam monitoring anomalies.
#[derive(Debug, Clone, PartialEq)]
pub enum AlertType {
    /// Pore water pressure exceeds safe threshold at a piezometer location.
    ExcessivePressure,
    /// Flow rate deviates significantly from the historical baseline.
    AbnormalFlow,
    /// A rapid change in readings between consecutive measurement cycles.
    RapidChange,
    /// Hydraulic gradient approaches or exceeds the critical piping gradient.
    PipingRisk,
    /// Uplift pressure ratio exceeds safe operational limits.
    UpliftExceeded,
}

/// A single alert generated by the monitoring system.
#[derive(Debug, Clone)]
pub struct DamAlert {
    /// Index of the sensor/location that triggered the alert.
    pub location_index: usize,
    /// Type of anomaly detected.
    pub alert_type: AlertType,
    /// Severity of the alert, normalized to [0, 1] where 1 is most severe.
    pub severity: f64,
}

/// Trend classification for a time series of readings.
#[derive(Debug, Clone, PartialEq)]
pub enum Trend {
    /// Readings are approximately constant over time.
    Stable,
    /// Readings are rising over time.
    Increasing,
    /// Readings are falling over time.
    Decreasing,
    /// Readings show no clear linear pattern (high variance, low R-squared).
    Erratic,
}

/// Status report produced by [`SeepageMonitor::process_readings`].
#[derive(Debug, Clone)]
pub struct DamStatus {
    /// Overall factor of safety (stabilizing / destabilizing forces).
    /// Values above 1.0 indicate the dam is stable.
    pub safety_factor: f64,
    /// List of alerts generated from the current reading cycle.
    pub alerts: Vec<DamAlert>,
    /// Ratio of measured uplift pressure to full hydrostatic head.
    /// Values approaching 1.0 indicate dangerous uplift conditions.
    pub uplift_pressure_ratio: f64,
    /// Overall trend of seepage flow rates.
    pub seepage_trend: Trend,
}

/// Stateful dam seepage monitor that tracks readings over time and generates
/// alerts when anomalous patterns are detected.
#[derive(Debug, Clone)]
pub struct SeepageMonitor {
    config: DamConfig,
    /// Rolling history of average flow rate per processing cycle.
    flow_history: Vec<f64>,
    /// Previous piezometer levels for rapid-change detection.
    previous_levels: Option<Vec<f64>>,
    /// Previous flow rates for rapid-change detection.
    previous_flows: Option<Vec<f64>>,
}

impl SeepageMonitor {
    /// Create a new seepage monitor with the given dam configuration.
    pub fn new(config: DamConfig) -> Self {
        Self {
            config,
            flow_history: Vec::new(),
            previous_levels: None,
            previous_flows: None,
        }
    }

    /// Process a set of piezometer level readings and flow rate measurements,
    /// returning a [`DamStatus`] with the current safety assessment and any alerts.
    ///
    /// # Arguments
    ///
    /// * `piezometer_levels` - Water head at each piezometer (meters above dam base).
    /// * `flow_rates` - Seepage flow rate at each measurement point (liters per minute).
    ///
    /// # Panics
    ///
    /// Does not panic. If input slices are empty the returned status will have a
    /// safety factor of `f64::INFINITY` and no alerts.
    pub fn process_readings(
        &mut self,
        piezometer_levels: &[f64],
        flow_rates: &[f64],
    ) -> DamStatus {
        let mut alerts = Vec::new();
        let full_head = self.config.reservoir_level_m;
        let full_head_pressure = WATER_DENSITY * GRAVITY * full_head;

        // --- Uplift pressure analysis ---
        let avg_pressure = if piezometer_levels.is_empty() {
            0.0
        } else {
            let sum: f64 = piezometer_levels
                .iter()
                .map(|&h| WATER_DENSITY * GRAVITY * h)
                .sum();
            sum / piezometer_levels.len() as f64
        };

        let uplift_ratio = if full_head_pressure > 0.0 {
            uplift_pressure_ratio(avg_pressure, full_head_pressure)
        } else {
            0.0
        };

        // Check each piezometer for excessive pressure
        for (i, &level) in piezometer_levels.iter().enumerate() {
            let ratio = if full_head > 0.0 {
                level / full_head
            } else {
                0.0
            };
            if ratio > PRESSURE_ALERT_THRESHOLD {
                let severity = ((ratio - PRESSURE_ALERT_THRESHOLD)
                    / (1.0 - PRESSURE_ALERT_THRESHOLD))
                    .min(1.0);
                alerts.push(DamAlert {
                    location_index: i,
                    alert_type: AlertType::ExcessivePressure,
                    severity,
                });
            }
        }

        // --- Uplift exceeded alert ---
        if uplift_ratio > UPLIFT_ALERT_THRESHOLD {
            let severity = ((uplift_ratio - UPLIFT_ALERT_THRESHOLD)
                / (1.0 - UPLIFT_ALERT_THRESHOLD))
                .min(1.0);
            alerts.push(DamAlert {
                location_index: 0,
                alert_type: AlertType::UpliftExceeded,
                severity,
            });
        }

        // --- Flow rate analysis ---
        let avg_flow = if flow_rates.is_empty() {
            0.0
        } else {
            flow_rates.iter().sum::<f64>() / flow_rates.len() as f64
        };

        self.flow_history.push(avg_flow);

        // Check for abnormal flow at each point
        if let Some(ref prev_flows) = self.previous_flows {
            for (i, (&current, &previous)) in
                flow_rates.iter().zip(prev_flows.iter()).enumerate()
            {
                if previous > 0.0 {
                    let change_ratio = (current - previous).abs() / previous;
                    if change_ratio > FLOW_ALERT_THRESHOLD {
                        let severity =
                            (change_ratio / (2.0 * FLOW_ALERT_THRESHOLD)).min(1.0);
                        alerts.push(DamAlert {
                            location_index: i,
                            alert_type: AlertType::AbnormalFlow,
                            severity,
                        });
                    }
                }
            }
        }

        // --- Rapid change detection ---
        if let Some(ref prev_levels) = self.previous_levels {
            for (i, (&current, &previous)) in
                piezometer_levels.iter().zip(prev_levels.iter()).enumerate()
            {
                let change = (current - previous).abs();
                let threshold = self.config.dam_height_m * 0.1; // 10% of dam height
                if change > threshold {
                    let severity = (change / self.config.dam_height_m).min(1.0);
                    alerts.push(DamAlert {
                        location_index: i,
                        alert_type: AlertType::RapidChange,
                        severity,
                    });
                }
            }
        }

        // --- Piping risk assessment ---
        // Estimate hydraulic gradient from piezometer distribution
        if piezometer_levels.len() >= 2 {
            let max_level = piezometer_levels
                .iter()
                .cloned()
                .fold(f64::NEG_INFINITY, f64::max);
            let min_level = piezometer_levels
                .iter()
                .cloned()
                .fold(f64::INFINITY, f64::min);
            let head_loss = max_level - min_level;
            // Approximate seepage path as dam base width ~ 2 * dam_height (typical)
            let seepage_path = self.config.dam_height_m * 2.0;
            if seepage_path > 0.0 {
                let gradient = piping_gradient(head_loss, seepage_path);
                let crit = critical_gradient(2.65); // typical soil Gs
                if gradient > PIPING_GRADIENT_THRESHOLD * crit {
                    let severity =
                        ((gradient / crit) - PIPING_GRADIENT_THRESHOLD).min(1.0);
                    // Find the location with highest pressure as piping location
                    let max_idx = piezometer_levels
                        .iter()
                        .enumerate()
                        .max_by(|a, b| a.1.partial_cmp(b.1).unwrap())
                        .map(|(i, _)| i)
                        .unwrap_or(0);
                    alerts.push(DamAlert {
                        location_index: max_idx,
                        alert_type: AlertType::PipingRisk,
                        severity: severity.max(0.0),
                    });
                }
            }
        }

        // --- Seepage trend ---
        let seepage_trend = flow_rate_trend(&self.flow_history);

        // --- Factor of safety ---
        // Simplified: stabilizing = dam weight - drain-relieved uplift
        // destabilizing = full uplift (unreduced)
        let dam_weight = self.config.dam_height_m
            * self.config.dam_height_m
            * 0.5
            * 2400.0  // concrete density ~2400 kg/m^3
            * GRAVITY; // per unit width
        let full_uplift = 0.5
            * full_head_pressure
            * self.config.dam_height_m; // triangular distribution
        let effective_uplift =
            full_uplift * (1.0 - self.config.drain_efficiency * (1.0 - uplift_ratio));
        let stabilizing = dam_weight;
        let destabilizing = effective_uplift;
        let safety_factor = factor_of_safety(stabilizing, destabilizing);

        // Update state for next cycle
        self.previous_levels = Some(piezometer_levels.to_vec());
        self.previous_flows = Some(flow_rates.to_vec());

        DamStatus {
            safety_factor,
            alerts,
            uplift_pressure_ratio: uplift_ratio,
            seepage_trend,
        }
    }

    /// Return a reference to the accumulated flow history.
    pub fn flow_history(&self) -> &[f64] {
        &self.flow_history
    }

    /// Reset the monitor state, clearing all history.
    pub fn reset(&mut self) {
        self.flow_history.clear();
        self.previous_levels = None;
        self.previous_flows = None;
    }
}

// ---------------------------------------------------------------------------
// Standalone utility functions
// ---------------------------------------------------------------------------

/// Compute the uplift pressure ratio: measured / full hydrostatic head.
///
/// Returns a value in [0, infinity). Values near 1.0 or above indicate
/// that the measured pore pressure equals or exceeds the full reservoir head.
///
/// # Arguments
///
/// * `measured_pressure` - Measured pore water pressure (Pa).
/// * `full_head_pressure` - Full hydrostatic head pressure (Pa) at the measurement depth.
pub fn uplift_pressure_ratio(measured_pressure: f64, full_head_pressure: f64) -> f64 {
    if full_head_pressure == 0.0 {
        return 0.0;
    }
    measured_pressure / full_head_pressure
}

/// Compute Lugeon permeability from a water pressure test.
///
/// The Lugeon unit is defined as the water loss in liters per minute per
/// meter of test section under a reference pressure of 1 MPa:
///
///   Lu = (Q / (P * L))
///
/// where Q is the flow rate in L/min, P is the test pressure in MPa, and
/// L is the test section length in meters.
///
/// # Arguments
///
/// * `flow_rate_lpm` - Water flow rate in liters per minute.
/// * `test_pressure_mpa` - Applied test pressure in megapascals.
/// * `test_length_m` - Length of the borehole test section in meters.
///
/// # Returns
///
/// Permeability in Lugeon units. Values < 1 Lu indicate very tight rock;
/// values > 10 Lu indicate significant permeability requiring grouting.
pub fn lugeon_permeability(
    flow_rate_lpm: f64,
    test_pressure_mpa: f64,
    test_length_m: f64,
) -> f64 {
    let denom = test_pressure_mpa * test_length_m;
    if denom == 0.0 {
        return 0.0;
    }
    flow_rate_lpm / denom
}

/// Check whether the phreatic surface (seepage line) is within safe limits.
///
/// The phreatic surface is reconstructed from piezometer readings along the
/// dam cross-section. It is considered safe if the maximum reading on the
/// downstream half of the dam remains below `(1 - PHREATIC_SAFETY_MARGIN) * dam_height`.
///
/// # Arguments
///
/// * `piezometer_readings` - Piezometer water levels (m above base), ordered
///   from upstream to downstream.
/// * `dam_height` - Total dam height in meters.
///
/// # Returns
///
/// `true` if the phreatic surface is within safe limits, `false` otherwise.
pub fn phreatic_surface_check(piezometer_readings: &[f64], dam_height: f64) -> bool {
    if piezometer_readings.is_empty() || dam_height <= 0.0 {
        return true; // no data, cannot assess
    }
    let n = piezometer_readings.len();
    // Downstream half of the piezometer array
    let downstream_start = n / 2;
    let safe_limit = dam_height * (1.0 - PHREATIC_SAFETY_MARGIN);
    for &level in &piezometer_readings[downstream_start..] {
        if level > safe_limit {
            return false;
        }
    }
    true
}

/// Classify the trend of a time series using simple linear regression.
///
/// Performs ordinary least squares regression on the input history and
/// classifies the trend based on the slope magnitude and R-squared value.
///
/// # Arguments
///
/// * `history` - Ordered sequence of measurements (oldest first).
///
/// # Returns
///
/// - [`Trend::Stable`] if the absolute slope is below the threshold.
/// - [`Trend::Increasing`] if the slope is positive and significant.
/// - [`Trend::Decreasing`] if the slope is negative and significant.
/// - [`Trend::Erratic`] if the R-squared is too low (poor linear fit).
pub fn flow_rate_trend(history: &[f64]) -> Trend {
    if history.len() < MIN_TREND_SAMPLES {
        return Trend::Stable;
    }
    let n = history.len() as f64;
    let sum_x: f64 = (0..history.len()).map(|i| i as f64).sum();
    let sum_y: f64 = history.iter().sum();
    let mean_x = sum_x / n;
    let mean_y = sum_y / n;

    let mut ss_xy = 0.0;
    let mut ss_xx = 0.0;
    let mut ss_yy = 0.0;
    for (i, &y) in history.iter().enumerate() {
        let dx = i as f64 - mean_x;
        let dy = y - mean_y;
        ss_xy += dx * dy;
        ss_xx += dx * dx;
        ss_yy += dy * dy;
    }

    if ss_xx == 0.0 {
        return Trend::Stable;
    }

    let slope = ss_xy / ss_xx;
    let r_squared = if ss_yy == 0.0 {
        1.0 // all values identical => perfect "fit"
    } else {
        (ss_xy * ss_xy) / (ss_xx * ss_yy)
    };

    // Normalize slope by mean_y to get a relative slope
    let relative_slope = if mean_y.abs() > 1e-12 {
        slope / mean_y.abs()
    } else {
        slope
    };

    if r_squared < TREND_R2_THRESHOLD {
        Trend::Erratic
    } else if relative_slope.abs() < TREND_SLOPE_THRESHOLD {
        Trend::Stable
    } else if relative_slope > 0.0 {
        Trend::Increasing
    } else {
        Trend::Decreasing
    }
}

/// Compute the factor of safety as the ratio of stabilizing to destabilizing forces.
///
/// FoS = stabilizing_forces / destabilizing_forces
///
/// # Arguments
///
/// * `stabilizing_forces` - Sum of forces resisting failure (e.g., dam weight, friction).
/// * `destabilizing_forces` - Sum of forces driving failure (e.g., uplift, hydrostatic thrust).
///
/// # Returns
///
/// Factor of safety. Values > 1.0 indicate stability; the dam is considered safe
/// when FoS exceeds the design minimum (typically 1.5 for normal loads, 1.2 for extreme).
pub fn factor_of_safety(stabilizing_forces: f64, destabilizing_forces: f64) -> f64 {
    if destabilizing_forces <= 0.0 {
        return f64::INFINITY;
    }
    stabilizing_forces / destabilizing_forces
}

/// Compute the hydraulic gradient for piping analysis.
///
/// i = h / L
///
/// where h is the head loss along the seepage path and L is the path length.
///
/// # Arguments
///
/// * `head_loss` - Difference in hydraulic head between upstream and downstream (meters).
/// * `seepage_path_length` - Length of the seepage path through or under the dam (meters).
///
/// # Returns
///
/// Dimensionless hydraulic gradient. When this approaches the critical gradient,
/// piping failure becomes likely.
pub fn piping_gradient(head_loss: f64, seepage_path_length: f64) -> f64 {
    if seepage_path_length <= 0.0 {
        return 0.0;
    }
    head_loss / seepage_path_length
}

/// Compute the critical hydraulic gradient (Terzaghi's criterion).
///
/// i_c = (G_s - 1) / (1 + e)
///
/// where G_s is the specific gravity of the soil particles and e is the void ratio.
/// Uses the default void ratio if a custom one is not needed; for custom void ratio
/// use [`critical_gradient_with_void_ratio`].
///
/// # Arguments
///
/// * `soil_specific_gravity` - Specific gravity of soil solids (dimensionless, typically 2.6-2.8).
///
/// # Returns
///
/// Critical hydraulic gradient (dimensionless). Piping initiates when the actual
/// gradient exceeds this value.
pub fn critical_gradient(soil_specific_gravity: f64) -> f64 {
    critical_gradient_with_void_ratio(soil_specific_gravity, DEFAULT_VOID_RATIO)
}

/// Compute the critical hydraulic gradient with a specified void ratio.
///
/// i_c = (G_s - 1) / (1 + e)
///
/// # Arguments
///
/// * `soil_specific_gravity` - Specific gravity of soil solids.
/// * `void_ratio` - Void ratio e of the soil.
pub fn critical_gradient_with_void_ratio(
    soil_specific_gravity: f64,
    void_ratio: f64,
) -> f64 {
    let denom = 1.0 + void_ratio;
    if denom <= 0.0 {
        return 0.0;
    }
    (soil_specific_gravity - 1.0) / denom
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    const EPSILON: f64 = 1e-9;

    // --- uplift_pressure_ratio tests ---

    #[test]
    fn test_uplift_ratio_basic() {
        // 50% uplift
        let ratio = uplift_pressure_ratio(147_150.0, 294_300.0);
        assert!((ratio - 0.5).abs() < 0.001);
    }

    #[test]
    fn test_uplift_ratio_zero_head() {
        // Zero full head pressure should return 0
        assert_eq!(uplift_pressure_ratio(100.0, 0.0), 0.0);
    }

    #[test]
    fn test_uplift_ratio_zero_measured() {
        assert!((uplift_pressure_ratio(0.0, 294_300.0)).abs() < EPSILON);
    }

    #[test]
    fn test_uplift_ratio_full() {
        // Equal pressures => ratio = 1.0
        let ratio = uplift_pressure_ratio(294_300.0, 294_300.0);
        assert!((ratio - 1.0).abs() < EPSILON);
    }

    #[test]
    fn test_uplift_ratio_exceeds() {
        // Measured exceeds full head (artesian conditions)
        let ratio = uplift_pressure_ratio(400_000.0, 294_300.0);
        assert!(ratio > 1.0);
    }

    // --- lugeon_permeability tests ---

    #[test]
    fn test_lugeon_basic() {
        // 10 L/min, 1 MPa, 5 m => 10 / (1 * 5) = 2 Lu
        let lu = lugeon_permeability(10.0, 1.0, 5.0);
        assert!((lu - 2.0).abs() < EPSILON);
    }

    #[test]
    fn test_lugeon_high_pressure() {
        // 10 L/min, 2 MPa, 5 m => 10 / (2 * 5) = 1 Lu
        let lu = lugeon_permeability(10.0, 2.0, 5.0);
        assert!((lu - 1.0).abs() < EPSILON);
    }

    #[test]
    fn test_lugeon_zero_pressure() {
        assert_eq!(lugeon_permeability(10.0, 0.0, 5.0), 0.0);
    }

    #[test]
    fn test_lugeon_zero_length() {
        assert_eq!(lugeon_permeability(10.0, 1.0, 0.0), 0.0);
    }

    #[test]
    fn test_lugeon_tight_rock() {
        // 0.5 L/min, 1 MPa, 5 m => 0.1 Lu (very tight)
        let lu = lugeon_permeability(0.5, 1.0, 5.0);
        assert!((lu - 0.1).abs() < EPSILON);
    }

    // --- phreatic_surface_check tests ---

    #[test]
    fn test_phreatic_safe() {
        // Readings decrease from upstream to downstream, all downstream below limit
        let readings = [25.0, 20.0, 15.0, 10.0];
        assert!(phreatic_surface_check(&readings, 30.0));
    }

    #[test]
    fn test_phreatic_unsafe() {
        // Downstream reading too high (exceeds 67% of dam height)
        let readings = [25.0, 20.0, 15.0, 25.0];
        assert!(!phreatic_surface_check(&readings, 30.0));
    }

    #[test]
    fn test_phreatic_empty_readings() {
        assert!(phreatic_surface_check(&[], 30.0));
    }

    #[test]
    fn test_phreatic_zero_height() {
        assert!(phreatic_surface_check(&[10.0, 5.0], 0.0));
    }

    #[test]
    fn test_phreatic_borderline() {
        // Exactly at the limit: 30 * (1 - 0.33) = 20.1
        let limit = 30.0 * (1.0 - PHREATIC_SAFETY_MARGIN);
        let readings = [25.0, limit - 0.01];
        assert!(phreatic_surface_check(&readings, 30.0));
    }

    // --- flow_rate_trend tests ---

    #[test]
    fn test_trend_stable() {
        // Very small monotonic drift that is below the relative slope threshold
        let history = [1.000, 1.001, 1.002, 1.003, 1.004];
        assert_eq!(flow_rate_trend(&history), Trend::Stable);
    }

    #[test]
    fn test_trend_increasing() {
        let history = [1.0, 1.5, 2.0, 2.5, 3.0];
        assert_eq!(flow_rate_trend(&history), Trend::Increasing);
    }

    #[test]
    fn test_trend_decreasing() {
        let history = [3.0, 2.5, 2.0, 1.5, 1.0];
        assert_eq!(flow_rate_trend(&history), Trend::Decreasing);
    }

    #[test]
    fn test_trend_erratic() {
        let history = [1.0, 10.0, 0.5, 8.0, 0.1, 12.0, 0.3];
        assert_eq!(flow_rate_trend(&history), Trend::Erratic);
    }

    #[test]
    fn test_trend_too_few_samples() {
        let history = [1.0, 2.0];
        assert_eq!(flow_rate_trend(&history), Trend::Stable);
    }

    #[test]
    fn test_trend_constant() {
        let history = [5.0, 5.0, 5.0, 5.0];
        assert_eq!(flow_rate_trend(&history), Trend::Stable);
    }

    // --- factor_of_safety tests ---

    #[test]
    fn test_fos_basic() {
        let fos = factor_of_safety(2_000_000.0, 1_000_000.0);
        assert!((fos - 2.0).abs() < EPSILON);
    }

    #[test]
    fn test_fos_unity() {
        let fos = factor_of_safety(1_000_000.0, 1_000_000.0);
        assert!((fos - 1.0).abs() < EPSILON);
    }

    #[test]
    fn test_fos_zero_destabilizing() {
        let fos = factor_of_safety(1_000_000.0, 0.0);
        assert!(fos.is_infinite());
    }

    #[test]
    fn test_fos_negative_destabilizing() {
        let fos = factor_of_safety(1_000_000.0, -100.0);
        assert!(fos.is_infinite());
    }

    // --- piping_gradient tests ---

    #[test]
    fn test_piping_gradient_basic() {
        // i = 10 / 50 = 0.2
        let grad = piping_gradient(10.0, 50.0);
        assert!((grad - 0.2).abs() < EPSILON);
    }

    #[test]
    fn test_piping_gradient_zero_path() {
        assert_eq!(piping_gradient(10.0, 0.0), 0.0);
    }

    #[test]
    fn test_piping_gradient_zero_head() {
        assert!((piping_gradient(0.0, 50.0)).abs() < EPSILON);
    }

    // --- critical_gradient tests ---

    #[test]
    fn test_critical_gradient_typical_soil() {
        // G_s = 2.65, e = 0.65 (default)
        // i_c = (2.65 - 1) / (1 + 0.65) = 1.65 / 1.65 = 1.0
        let ic = critical_gradient(2.65);
        assert!((ic - 1.0).abs() < EPSILON);
    }

    #[test]
    fn test_critical_gradient_heavy_soil() {
        // G_s = 2.75, e = 0.65
        // i_c = 1.75 / 1.65 = 1.0606...
        let ic = critical_gradient(2.75);
        assert!((ic - (1.75 / 1.65)).abs() < 1e-6);
    }

    #[test]
    fn test_critical_gradient_with_void_ratio() {
        // G_s = 2.65, e = 0.50
        // i_c = 1.65 / 1.50 = 1.1
        let ic = critical_gradient_with_void_ratio(2.65, 0.50);
        assert!((ic - 1.1).abs() < EPSILON);
    }

    #[test]
    fn test_critical_gradient_high_void_ratio() {
        // G_s = 2.65, e = 1.0
        // i_c = 1.65 / 2.0 = 0.825
        let ic = critical_gradient_with_void_ratio(2.65, 1.0);
        assert!((ic - 0.825).abs() < EPSILON);
    }

    // --- SeepageMonitor integration tests ---

    #[test]
    fn test_monitor_normal_conditions() {
        let config = DamConfig {
            dam_height_m: 30.0,
            num_piezometers: 4,
            reservoir_level_m: 28.0,
            drain_efficiency: 0.6,
        };
        let mut monitor = SeepageMonitor::new(config);
        let levels = [20.0, 15.0, 10.0, 5.0];
        let flows = [0.5, 0.6, 0.55, 0.52];
        let status = monitor.process_readings(&levels, &flows);
        assert!(status.safety_factor > 1.0);
        assert!(status.uplift_pressure_ratio < 1.0);
    }

    #[test]
    fn test_monitor_high_pressure_alert() {
        let config = DamConfig {
            dam_height_m: 30.0,
            num_piezometers: 3,
            reservoir_level_m: 28.0,
            drain_efficiency: 0.5,
        };
        let mut monitor = SeepageMonitor::new(config);
        // First piezometer reads very high relative to reservoir level
        let levels = [27.0, 15.0, 5.0];
        let flows = [0.5, 0.5, 0.5];
        let status = monitor.process_readings(&levels, &flows);
        let pressure_alerts: Vec<_> = status
            .alerts
            .iter()
            .filter(|a| a.alert_type == AlertType::ExcessivePressure)
            .collect();
        assert!(
            !pressure_alerts.is_empty(),
            "Expected ExcessivePressure alert for reading 27.0 with reservoir at 28.0"
        );
        assert_eq!(pressure_alerts[0].location_index, 0);
    }

    #[test]
    fn test_monitor_rapid_change_alert() {
        let config = DamConfig {
            dam_height_m: 30.0,
            num_piezometers: 2,
            reservoir_level_m: 28.0,
            drain_efficiency: 0.5,
        };
        let mut monitor = SeepageMonitor::new(config);
        // First reading: normal
        let _ = monitor.process_readings(&[15.0, 10.0], &[0.5, 0.5]);
        // Second reading: big jump at piezometer 0
        let status = monitor.process_readings(&[20.0, 10.0], &[0.5, 0.5]);
        let rapid_alerts: Vec<_> = status
            .alerts
            .iter()
            .filter(|a| a.alert_type == AlertType::RapidChange)
            .collect();
        assert!(
            !rapid_alerts.is_empty(),
            "Expected RapidChange alert for 5m change in 30m dam"
        );
    }

    #[test]
    fn test_monitor_abnormal_flow_alert() {
        let config = DamConfig {
            dam_height_m: 30.0,
            num_piezometers: 2,
            reservoir_level_m: 28.0,
            drain_efficiency: 0.5,
        };
        let mut monitor = SeepageMonitor::new(config);
        let _ = monitor.process_readings(&[15.0, 10.0], &[1.0, 1.0]);
        // Flow rate doubles at index 0
        let status = monitor.process_readings(&[15.0, 10.0], &[2.0, 1.0]);
        let flow_alerts: Vec<_> = status
            .alerts
            .iter()
            .filter(|a| a.alert_type == AlertType::AbnormalFlow)
            .collect();
        assert!(
            !flow_alerts.is_empty(),
            "Expected AbnormalFlow alert for doubled flow rate"
        );
    }

    #[test]
    fn test_monitor_empty_readings() {
        let config = DamConfig {
            dam_height_m: 30.0,
            num_piezometers: 0,
            reservoir_level_m: 28.0,
            drain_efficiency: 0.5,
        };
        let mut monitor = SeepageMonitor::new(config);
        let status = monitor.process_readings(&[], &[]);
        assert!(status.safety_factor > 0.0);
        assert!(status.alerts.is_empty());
    }

    #[test]
    fn test_monitor_flow_history_accumulates() {
        let config = DamConfig {
            dam_height_m: 30.0,
            num_piezometers: 2,
            reservoir_level_m: 28.0,
            drain_efficiency: 0.5,
        };
        let mut monitor = SeepageMonitor::new(config);
        for _ in 0..5 {
            monitor.process_readings(&[15.0, 10.0], &[1.0, 1.0]);
        }
        assert_eq!(monitor.flow_history().len(), 5);
    }

    #[test]
    fn test_monitor_reset() {
        let config = DamConfig {
            dam_height_m: 30.0,
            num_piezometers: 2,
            reservoir_level_m: 28.0,
            drain_efficiency: 0.5,
        };
        let mut monitor = SeepageMonitor::new(config);
        monitor.process_readings(&[15.0, 10.0], &[1.0, 1.0]);
        assert!(!monitor.flow_history().is_empty());
        monitor.reset();
        assert!(monitor.flow_history().is_empty());
    }

    #[test]
    fn test_monitor_uplift_exceeded_alert() {
        let config = DamConfig {
            dam_height_m: 20.0,
            num_piezometers: 2,
            reservoir_level_m: 20.0,
            drain_efficiency: 0.0, // no drains
        };
        let mut monitor = SeepageMonitor::new(config);
        // Both piezometers reading very high => high average uplift
        let levels = [18.0, 16.0];
        let flows = [0.5, 0.5];
        let status = monitor.process_readings(&levels, &flows);
        let uplift_alerts: Vec<_> = status
            .alerts
            .iter()
            .filter(|a| a.alert_type == AlertType::UpliftExceeded)
            .collect();
        assert!(
            !uplift_alerts.is_empty(),
            "Expected UpliftExceeded alert for high average piezometric head"
        );
    }

    #[test]
    fn test_monitor_seepage_trend_stable() {
        let config = DamConfig {
            dam_height_m: 30.0,
            num_piezometers: 2,
            reservoir_level_m: 28.0,
            drain_efficiency: 0.5,
        };
        let mut monitor = SeepageMonitor::new(config);
        for _ in 0..5 {
            monitor.process_readings(&[15.0, 10.0], &[1.0, 1.0]);
        }
        let status = monitor.process_readings(&[15.0, 10.0], &[1.0, 1.0]);
        assert_eq!(status.seepage_trend, Trend::Stable);
    }

    #[test]
    fn test_monitor_seepage_trend_increasing() {
        let config = DamConfig {
            dam_height_m: 30.0,
            num_piezometers: 1,
            reservoir_level_m: 28.0,
            drain_efficiency: 0.5,
        };
        let mut monitor = SeepageMonitor::new(config);
        let flow_series = [1.0, 2.0, 3.0, 4.0, 5.0];
        for &f in &flow_series {
            monitor.process_readings(&[15.0], &[f]);
        }
        let status = monitor.process_readings(&[15.0], &[6.0]);
        assert_eq!(status.seepage_trend, Trend::Increasing);
    }

    #[test]
    fn test_alert_severity_bounded() {
        let config = DamConfig {
            dam_height_m: 10.0,
            num_piezometers: 1,
            reservoir_level_m: 10.0,
            drain_efficiency: 0.0,
        };
        let mut monitor = SeepageMonitor::new(config);
        // Extreme reading
        let status = monitor.process_readings(&[10.0], &[100.0]);
        for alert in &status.alerts {
            assert!(
                alert.severity >= 0.0 && alert.severity <= 1.0,
                "Alert severity {} out of bounds for {:?}",
                alert.severity,
                alert.alert_type
            );
        }
    }

    #[test]
    fn test_piping_gradient_critical_comparison() {
        // For G_s = 2.65, e = 0.65 => i_c = 1.0
        // A gradient of 0.5 should be below critical
        let gradient = piping_gradient(10.0, 20.0); // 0.5
        let crit = critical_gradient(2.65); // 1.0
        assert!(gradient < crit, "0.5 should be below critical gradient 1.0");
    }
}
